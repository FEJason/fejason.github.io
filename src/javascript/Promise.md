# 你真的了解 Promise 吗？

1. 什么是事件阻塞
2. 什么是 Promise
3. 为什么要使用 Promise
4. Promise 的作用是什么
5. 什么是事件循环
6. 什么是宏任物和微任务
7. async 和 await 解决了什么问题
8. async 和 await 详解
9. 手写一个 Promise
10. Promise 嵌套

- 比如某个任务需要等待调用某个获取接口的函数执行后再继续执行
- 返回表单效验的 Promise
- 当函数使用了 async , 内部可以不用写 return new Promise()。async 函数会自动将返回值包装成一个 Promise 对象

## 什么是事件阻塞 se

事件阻塞是指当 JavaScript 代码执行一个长时间运行的操作时（例如大量计算或 I/O 操作），会阻塞后续事件的执行，导致页面无响应或卡顿。事件阻塞的主要原因是 JavaScript 是单线程的，所有的 JavaScript 代码都是在一个主线程上执行的。当主线程正在执行一个长时间运行的操作时，它就无法同时处理其他事件的请求，例如用户交互、定时器、异步请求等。

JavaScript 是单线程的原因是因为它最初是为了处理简单的用户交互而设计的。如果 JavaScript 是多线程的，那么不同的线程可能会同时修改同一个变量，从而导致不可预料的结果。为了避免这种情况，JavaScript 选择了单线程模型。

为了避免事件阻塞，可以采用异步编程的方式，使用异步 API 和回调函数来处理长时间运行的操作。异步编程的原理是，将长时间运行的操作放到一个单独的线程中执行，然后在操作完成后，将结果传递给 JavaScript 主线程进行处理。这样就可以避免长时间运行的操作阻塞 JavaScript 主线程，从而保证页面的响应性能。

## 什么是 Promise

Promise 是一种用于异步编程的 JavaScript 对象，它可以解决回调地狱的问题并提供更好的代码可读性和可维护性。Promise 可以看做是一种承诺，表示在未来某个时间点会返回一个结果，这个结果可以是成功的，也可以是失败的。

Promise 对象有三种状态：

Pending（等待状态）：Promise 对象刚被创建时的初始状态，此时还没有返回结果。
Fulfilled（成功状态）：当 Promise 对象返回结果时，进入成功状态，并把结果作为参数传递给后续的 then 方法。
Rejected（失败状态）：当 Promise 对象返回错误结果时，进入失败状态，并把错误信息作为参数传递给后续的 catch 方法。
Promise 对象可以通过 then 方法和 catch 方法进行链式调用。then 方法用来处理成功状态的结果，catch 方法用来处理失败状态的结果。在链式调用中，每一个 then 方法都会返回一个新的 Promise 对象，从而实现了链式调用的效果。

Promise 对象的优点在于可以避免回调地狱的问题，使得异步代码更加清晰、易懂、易维护。同时，Promise 对象还可以提供更好的错误处理和便于组合操作的功能。

## 为什么要使用 Promise

在传统的回调函数中，如果有多个异步操作需要执行，嵌套的回调会导致代码难以阅读和维护。而 Promise 通过链式调用的方式，可以避免这种嵌套的情况，使得代码更加清晰易懂。

Promise 可以处理异步操作，使得代码更加健壮。例如，当需要从服务器获取数据时，我们可以使用 Promise 来处理异步请求，从而避免阻塞 UI 线程。

Promise 提供了 catch 方法来处理异常情况，使得代码更加健壮和可维护。在 Promise 中，任何一个操作的错误都可以在 catch 方法中捕获并进行处理，从而避免了在回调函数中抛出异常导致程序崩溃的情况。

使用 Promise 可以方便地组合多个异步操作，使得代码更加简洁和可读性更强。例如，我们可以使用 Promise.all 方法来并行执行多个异步操作，并在所有操作完成后进行下一步处理。

Promise 构造函数的参数是一个函数，该函数接受两个参数：resolve 和 reject。resolve 函数将 Promise 对象的状态从“未完成”改变为“成功”，并将异步操作的结果作为参数传递给 then 方法；而 reject 函数则将 Promise 对象的状态从“未完成”改变为“失败”，并将失败原因作为参数传递给 catch 方法或 then 方法的第二个参数。

在异步操作完成后，可以调用 resolve 方法将异步操作的结果传递给 then 方法。

```js
new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, Promise!')
  }, 1000)
}).then(result => {
  console.log(result) // 输出: 'Hello, Promise!'
})
```

如果异步操作失败，则可以调用 reject 方法将失败原因传递给 catch 方法或 then 方法的第二个参数。

```js
new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error('Something went wrong!'))
  }, 1000)
}).catch(error => {
  console.log(error.message) // 输出: 'Something went wrong!'
})
```

总之，Promise 构造函数的参数可以让我们在异步操作完成后，根据结果来改变 Promise 对象的状态，并将结果传递给 then 方法或失败原因传递给 catch 方法。

## Promise 的作用是什么

Promise 是一种用于异步编程的 JavaScript 对象，它可以解决回调地狱的问题并提供更好的代码可读性和可维护性。

处理异步操作：在 JavaScript 中，异步操作比如 Ajax 请求、定时器等是很常见的，它们不能立即得到结果，而是需要等待一段时间才能得到结果。使用 Promise 可以方便地处理异步操作，避免阻塞 UI 线程，提高页面响应速度。
避免回调地狱：在传统的回调函数中，如果有多个异步操作需要执行，嵌套的回调会导致代码难以阅读和维护。而 Promise 通过链式调用的方式，可以避免这种嵌套的情况，使得代码更加清晰易懂。
提供更好的错误处理：Promise 提供了 catch 方法来处理异常情况，使得代码更加健壮和可维护。在 Promise 中，任何一个操作的错误都可以在 catch 方法中捕获并进行处理，从而避免了在回调函数中抛出异常导致程序崩溃的情况。
便于组合操作：使用 Promise 可以方便地组合多个异步操作，使得代码更加简洁和可读性更强。例如，我们可以使用 Promise.all 方法来并行执行多个异步操作，并在所有操作完成后进行下一步处理。

## 再探事件循环

事件循环(Event Loop)是 JavaScript 处理异步操作的机制，它使得 JavaScript 能够在单线程上执行异步操作。

事件循环的机制是基于消息队列的。当 JavaScript 执行异步操作时，比如发起一个网络请求或设置一个定时器，这些操作不会阻塞主线程，而是被放入消息队列中。一旦主线程的任务执行完成，事件循环就会从消息队列中取出一个任务，将其加入到主线程的任务队列中执行。

### 宏任务 (Macrotask)

- 包括：script 整体代码块、setTimeout、setInterval、I/O 操作等。
- 每次事件循环只会从宏任务队列中取出一个宏任务来执行。

> 在计算机科学中，I/O 操作指的是输入（Input）和输出（Output）操作。这些操作是计算机与外部世界交互的方式，包括接收用户输入、向显示器输出信息、读取文件或写入数据到磁盘等。简单来说，任何涉及数据进出计算机系统的操作都可以被认为是 I/O 操作。

### 微任务 (Microtask)

- 包括：Promise.then/catch/finally、MutationObserver 等。
- 在当前宏任务执行完毕后，会立即检查并清空所有微任务队列中的任务（即执行所有微任务）。

事件循环的执行顺序：

- 执行全局代码（第一个宏任务），遇到同步任务直接执行，遇到异步任务（微任务、宏任务），加入到任务队列。
- 当前宏任务执行完毕，执行所有微任务。
- 执行下一个宏任务，重复上述过程。

示例代码

```js
console.log('A') // 同步代码

setTimeout(() => {
  console.log('B') // 宏任务
}, 0)

Promise.resolve().then(() => {
  console.log('C') // 微任务
})

setTimeout(() => {
  console.log('D') // 宏任务
}, 0)

Promise.resolve().then(() => {
  console.log('E') // 微任务
})
```

输出结果：

```
A
C
E
B
D
```

执行流程解析

初始状态

- 宏任务队列：[script]
- 微任务队列：[]

第一步：执行全局代码（第一个宏任务）

- console.log('A') 输出 A。
- 遇到第一个 setTimeout，将其回调函数加入宏任务队列：[setTimeout B]。
- 遇到第一个 Promise.resolve().then()，将其回调函数加入微任务队列：[Promise C]。
- 遇到第二个 setTimeout，将其回调函数加入宏任务队列：[setTimeout B, setTimeout D]。
- 遇到第二个 Promise.resolve().then()，将其回调函数加入微任务队列：[Promise C, Promise E]。

此时：

- 宏任务队列：[setTimeout B, setTimeout D]
- 微任务队列：[Promise C, Promise E]

第二步：执行微任务队列

- 当前宏任务（script）执行完毕后，清空微任务队列：
  - 执行 Promise C 回调，输出 C。
  - 执行 Promise E 回调，输出 E。

此时：

- 宏任务队列：[setTimeout B, setTimeout D]
- 微任务队列：[]

第三步：执行下一个宏任务

- 从宏任务队列中取出第一个 setTimeout B 并执行，输出 B。

此时：

- 宏任务队列：[setTimeout D]
- 微任务队列：[]

第四步：执行下一个宏任务

- 从宏任务队列中取出 setTimeout D 并执行，输出 D。

更复杂的例子：

```js
console.log('同步代码 1')

setTimeout(() => {
  console.log('宏任务 1')
  Promise.resolve().then(() => {
    console.log('微任务 3')
  })
}, 0)

Promise.resolve().then(() => {
  console.log('微任务 1')
  setTimeout(() => {
    console.log('宏任务 2')
  }, 0)
})

Promise.resolve().then(() => {
  console.log('微任务 2')
})

console.log('同步代码 2')
```

输出结果：

```
同步代码 1
同步代码 2
微任务 1
微任务 2
宏任务 1
微任务 3
宏任务 2
```

执行流程解析

初始状态

- 宏任务队列：[script]
- 微任务队列：[]

第一步：执行全局代码（第一个宏任务）

- 执行同步代码，输出 "同步代码 1"。
- 遇到 setTimeout，将其回调函数加入宏任务队列：
  - 宏任务队列：[宏任务 1]
- 遇到第一个 Promise.resolve().then()，将其回调函数加入微任务队列：
  - 微任务队列：[微任务 1]
- 遇到第二个 Promise.resolve().then()，将其回调函数加入微任务队列：
  - 微任务队列：[微任务 1, 微任务 2]
- 执行同步代码，输出 "同步代码 2"。

此时的状态：

- 宏任务队列：[宏任务 1]
- 微任务队列：[微任务 1, 微任务 2]

第二步：清空微任务队列

- 当前宏任务（script）执行完毕后，清空微任务队列：
  - 执行 微任务 1 回调，输出 微任务 1。
  - 在 微任务 1 中遇到嵌套的 setTimeout，将其回调函数加入宏任务队列：
    - 宏任务队列：[宏任务 1, 宏任务 2]
  - 执行 微任务 2 回调，输出 微任务 2。

此时的状态：

- 宏任务队列：[宏任务 1, 宏任务 2]
- 微任务队列：[]

第三步：执行下一个宏任务

从宏任务队列中取出第一个 宏任务 1 并执行

- 输出 "宏任务 1"。
- 遇到嵌套的 Promise.resolve().then，将 "微任务 3" 放入微任务队列：
  - 微任务队列：[微任务 3]

此时的状态：

- 宏任务队列：[宏任务 2]
- 微任务队列：[微任务 3]

第四步：清空微任务队列

当前宏任务（宏任务 1）执行完毕后，开始清空微任务队列。

- 执行 微任务 3 回调：输出 微任务 3。

此时的状态：

- 宏任务队列：[宏任务 2]
- 微任务队列：[]

第五步：继续执行下一个宏任务

从宏任务队列中取出第一个宏任务（宏任务 2）并执行。

- 输出 "宏任务 2"

深入示例：

```js
console.log('A')

setTimeout(() => console.log('B'), 0)

Promise.resolve()
  .then(() => {
    console.log('C')
    return Promise.resolve()
  })
  .then(() => console.log('D'))

console.log('E')
```

输出结果：

```
A
E
C
D
B
```

async/await 版：

```js
async function foo() {
  console.log('X') // 函数内部同步代码

  // await 会将后续代码推迟到微任务队列中执行
  await Promise.resolve()
  console.log('Y')
}

console.log('1') // 同步代码

foo() // 同步代码

console.log('2') // 同步代码
```

输出结果：

```
1
X
2
Y
```

## 总结

### 什么是事件循环

事件循环(Event Loop)是 JavaScript 处理异步操作的机制。

它使得 JavaScript 能够在单线程上执行异步操作。

事件循环机制可以有效地协调异步操作和主线程执行任务之间的关系，保证程序的正确性和效率。
同时，事件循环还可以防止 JavaScript 的阻塞，提高程序的响应性能

### 事件循环的执行流程：

- 执行全局代码（第一个宏任务），遇到同步任务直接执行，遇到异步任务（微任务、宏任务），加入到任务队列。
- 当前宏任务执行完毕，执行所有微任务。
- 执行下一个宏任务，重复上述过程。

### 重点：

- 在每个事件循环迭代中，首先会执行一个宏任务（从宏任务队列中取出），然后执行所有已排队的微任务（直到微任务队列为空）。
- 微任务的设计允许你在当前操作结束后立即响应某些状态变化，而无需等待下一次事件循环迭代。这对于需要确保一系列操作在一个逻辑单元内完成是非常有用的，比如在 Promise 链式调用中，确保前一个 then 方法中的操作完成后，紧接着执行下一个 then 方法中的操作，而不是等到下一轮事件循环。
- 宏任务内部的微任务会在当前宏任务执行完后立即执行。
